# 트랜잭션 (Transaction)

## 1. 트랜잭션의 개념

**트랜잭션**은 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성입니다.
데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위입니다.
하나의 논리적 기능을 수행하기 위한 작업 단위
데이터베이스에서 일어나는 연산의 집합

## 2. 트랜잭션의 특성 (ACID)

### 2.1 원자성 (Atomicity)
- 트랜잭션을 구성하는 연산 전체가 모두 정상적으로 실행되거나 모두 취소되어야 하는 성질
- 트랜잭션의 연산 전체가 성공 또는 실패(All or Nothing)되어야 하는 성질
완전하게 수행이 완료되지 않으면 전혀 수행되지 않아야 한다.
연산은 Commit, Rollback을 이용하여 적용 또는 취소로 한꺼번에 완료되어야 한다.
중간에 하나의 오류가 발생하더라도 취소가 되어야 한다.

**주요 기법:**
- Commit/Rollback
- 회복성 보장

### 2.2 일관성 (Consistency)
- 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 하는 성질
트랜잭션이 실행되기 전과 실행된 후의 데이터베이스 상태가 일관성을 유지해야 함을 의미한다.
트랜잭션의 무결성을 보장하는 중요한 특성 중 하나이다

**주요 기법:**
- 무결성 제약조건
- 동시성 제어

### 2.3 격리성, 고립성 (Isolation)
- 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 한다는 성질
트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 한다.

격리성이 보장되지 않을 때 문제점
Dirty Read
다른 트랜잭션이 아직 Commit 되지 않은 데이터를 읽는 경우

Nor-repeatable Read
동일한 쿼리를 실행했을 때 결과가 다른 경우

Phantom Read
한 트랜잭션이 조회한 결과와 다른 결과가 나오는 경우

격리 수준
가장 높은 수준 : Serializable Level
가장 낮은 수준 : Read Uncommitted Level

**주요 기법:**
- 고립화수준(레벨 0, 1, 2, 3)

### 2.4 영속성 (Durability)
- 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장되어야 하는 성질
트랜잭션의 완료 결과가 데이터베이스의 영구히 기억된다.
시스템 장애나 다른 문제로 인해 데이터베이스가 중단되더라도, 작업이 성공적으로 완료된 결과는 영구적으로 유지되어야 한다.
영속성을 보장하기 위해 데이터베이스는 일반적으로 로그 파일을 사용한다.

**주요 기법:**
- 회복기법

트랜잭션 연산
트랜잭션 연산에는 COMMIT와 ROLLBACK이 있으며 하나의 트랜잭션은 COMMIT이나 ROLLBACK이 되어야 한다.
COMMIT 
트랜잭션이 성공적으로 종료된 후 수정된 내용을 지속적으로 유지하기 위한 연산
ROLLBACK
트랜잭션이 비정상적으로 수행되었거나 오류가 발생했을 때 수행 작업을 취소하고 이전 상태로 되돌리기 위한 연산

## 3. 트랜잭션의 상태

| 상태 | 설명 |
|------|------|
| **활동 상태 (Active)** | - 초기 상태<br>- 트랜잭션이 실행 중일 때 가지는 상태 |
현재 트랜잭션이 실행 중인 상태
| **부분 완료 상태 (Partially Committed)** | - 마지막 명령문이 실행된 후에 가지는 상태 |
실행을 모두 마치고, 데이터베이스에 결과를 저장하기 직전의 상태
부분 완료가 되었다 하더라도 실패로 이어질 수 있다.
| **완료 상태 (Committed)** | - 트랜잭션이 성공적으로 완료된 후 가지는 상태 |
트랜잭션의 연산을 정상적으로 마치고, 연산 결과를 데이터베이스에 저장한 상태
| **실패 상태 (Failed)** | - 정상적인 실행이 더 이상 진행될 수 없을 때 가지는 상태 |
트랜잭션 실행 중 오류로 인해 정상적인 처리가 되지 않아 원자성과 일관성에 문제가 발생하여 더 이상 처리가 불가능한 상태
| **철회 상태 (Aborted)** | - 트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작 전 상태로 환원된 상태 |
트랜잭션 실행이 실패해서 다시 원 상태로 복귀되는 상태

## 4. 트랜잭션 제어

### 4.1 트랜잭션 제어언어 (TCL)
트랜잭션 제어언어는 TCL(Transaction Control Language)이라고 하며, 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어입니다.

### 4.2 TCL 명령어

| 명령어 | 설명 |
|--------|------|
| **COMMIT** | - 트랜잭션 확정<br>- 트랜잭션을 메모리에 영구적으로 저장 |
| **ROLLBACK** | - 트랜잭션 취소<br>- 트랜잭션 내역을 저장 무효화 |
| **CHECKPOINT** | - 저장 시기 설정<br>- ROLLBACK을 위한 시점을 지정 |


트랜잭션 완료
트랜잭션이 정상적으로 완료되었다 하더라도 COMMIT 연산을 수행하지 않으면 수행된 결과가 유지될 수 없다.

Recovery 연산
트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업
Redo 작업

Undo 작업

즉각 갱신법
데이터를 갱신하면 트랜잭션이 완료되기 전에 실제 데이터베이스에 반영하는 방법
회복 작업을 위해서 갱신 내용을 별로 Log로 기록해야 한다
Redo, Undo 모두 사용할 수 있다.

Redo
갱신이 완료된 데이터를 로그 파일을 이용하여 복원한다
이미 진행 중이었던 작업을 다시 한다.
Undo
변경되었던 데이터를 취소하여 원래의 내용으로 복원한다.
처음에 있던 옛 데이터를 이용하여 데이터를 복원한다.
했던 작업을 다시 하지 않고 원 상태로 되돌린다.

## 5. 병행 제어 (Concurrency Control)

### 5.1 병행 제어 개념
병행 제어는 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호 작용을 제어하는 기법입니다.
동시에 수행되는 트랜잭션들을 일관성있게 처리하기 위해 제어하는 것
병행 실행 시 트랜잭션 간의 격리성을 유지하여 트랜잭션 수행에 문제가 발생하지 않도록 제어하는 것을 병행 제어라고 한다.
대표적인 병행 제어의 방법으로 로킹(Locking) 기법이 있다.

### 5.2 병행 제어의 목적
- 데이터베이스의 공유를 최대화
- 시스템의 활용도를 최대화
- 데이터베이스의 일관성을 유지
- 사용자에 대한 응답시간을 최소화
데이터베이스의 일관성을 최대화
시스템 활용도를 최대화
사용자에 대한 응답 시간을 최소화

병행 수행의 문제점
갱신 분실
같은 데이터에 대해 둘 이상의 트랜잭션이 동시에 갱신할 때, 갱신 결과의 일부가 없어지는 현상
비완료 의존성
하나의 트랜잭션 수행이 실패한 후 회복하기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상
모순성
하나의 트랜잭션이 여러 데이터 갱신 연산을 수행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져옴으로써 데이터의 불일치가 발생하는 것을 의미
연쇄 복귀
수행되던 둘 이상의 트랜잭션 중 어느 한 트랜잭션에 오류가 발생하여 Rollbakc 하는 경우 다른 트랜잭션들도 함께 Rollback되는 현상

병행 제어의 종류
로킹, 타임스탬프, 최적 병행 수행, 다중 버전 기법

### 5.3 병행 제어 기법

#### 로킹 (Locking)
- 하나의 트랜잭션이 실행되는 동안 특정 데이터 항목에 대해 다른 트랜잭션이 동시에 접근하지 못하도록 상호배제(Mutual Exclusion) 기능을 제공
- 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
- 로킹 단위가 작아지면 데이터베이스 공유도가 증가하나 로킹 오버헤드도 증가
로킹 단위
운영체제에서 임계구역과 유사한 개념, 운영체제에서는 모든 공유 자원이 임계구역이지만 데이터베이스의 로킹 단위는 분할된 트랜잭션의 크기, 영역을 말하는 것.

로킹의 특징
하나의 트랜잭션이 데이터를 액세스하는 동안 다른 트랜잭션이 그 데이터 항목을 액세스할 수 없도록 하는 병행 제어 기법
로킹 단위가 커지면 로크(로킹 단위 별로 나누어진 각각의 구획)의 수가 적어 관리가 쉬워지지만 병행성 수준은 낮아진다.
로킹 단위가 작으면 로크의 수가 많아 관리가 어려워지지만 병행성 수준은 높아진다.
로킹의 대상이 되는 객체(파일, 테이블, 필드, 레코드)의 크기를 로킹 단위라고 한다.
하나의 트랜잭션이 실행될 때는 'LOCK'을 설정해 다른 트랜잭션이 데이터에 접근하지 못하도록 잠근 후 실행하고, 실행이 완료되면 'UNLOCK'을 통해 해제한다.

2단계 로킹(2-Phase Locking)
직렬성(트랜잭션을 순서대로 처리하는 것)은 보장하지만, 교착상태 예방은 불가능하다.
트랜잭션의 로크 요청과 해제 요청을 2단계로 실시한다.
확장 단계와 축소 단계의 두 단계가 있다.
2단계 로킹은 동시성 제어에 매우 효과적이지만, 교착상태 문제를 초래할 수 있으므로 잘 설계되고 구현되어야 한다.
확장 단계
트랜잭션이 데이터베이스에서 데이터를 읽거나 쓰기 시작하면서 필요한 모든 잠금을 확보하는 단계
모든 필요한 잠금을 획득하고, 다른 트랜잭션이 해당 데이터에 대한 접근을 막는다
잠금을 놓치면 다시 얻을 수 없다.

축소 단계
트랜잭션이 모든 작업을 완료하고 커밋 또는 롤백을 실행할 때 잠금을 해제하는 단계
모든 데이터 작업이 완료되고 커밋 또는 롤백이 실행되기 전에 모든 잠금을 유지한다.
커밋을 실행하면 트랜잭션은 모든 잠금을 해제하고 롤백을 실행하면 모든 잠금을 롤백한다.

잠금의 상태 2가지
공유 잠금(S Lock)
다른 트랜잭션이 읽기만 가능한 상태
다른 트랜잭션이 동시에 공유 잠금을 요청할 수 있다.

배타적 잠금(X Lock)
다른 트랜잭션이 읽기 및 쓰기가 불가능한 상태
다른 트랜잭션이 동시에 배타적 잠금을 요청할 수 없다

타임스탬프(Timestamp)
트랜잭션이 DBMS로부터 유일한 타임스탬프(시간 허가 인증 도장)을 부여받는다
동시성 제어를 위한 직렬화 기법으로 트랜잭션 간의 순서를 미리 정하는 방법

최적 병행 수행(OCC: Optimistic Concurrency Control)
각 트랜잭션이 데이터를 변경하기 전에 충돌을 감지하여 제어하는 방식으로 데이터베이스 시스템의 성능을 향상시킬 수 있는 장점이 있다.
데이터의 변경이 적은 경우에 효과적이다.
데이터의 변경이 빈번하게 일어날 때는 다른 병행 제어 기법보다 효과적이지 않을 수 있다.
트랜잭션은 해당 데이터의 버전 정보와 자신이 읽은 버전 정보를 비교하여 충돌을 감지하고, 충돌이 발생하면 롤백하거나 재시도한다.
데이터베이스 시스템의 성능과 확장성을 향상시킬 수 있다.

다중 버전 기법(MVCC: Multi-Version Concurrency Control)
각 트랜잭션이 실행될 때, 트랜잭션의 시작 시점에 해당하는 데이터의 버전을 할당하여 다른 트랜잭션이 해당 데이터를 수정하는 것을 방지한다
다수의 트랜잭션이 동시의 데이터베이스에 접근할 때, 데이터의 일관성을 유지하면서 병행성을 보장할 수 있는 기법
각 트랜잭션은 자신만의 버전을 갖게 되며, 데이터의 변경은 새로운 버전을 생성하여 해당 트랜잭션이 사용하도록 한다.
각 데이터는 버전별로 저장되며, 트랜잭션은 시작 지점에 해당하는 버전을 선택하여 작업을 수행한다. 만약 다른 트랜잭션이 해당 데이터를 변경하면, 새로운 버전이 생성되고, 이전 버전은 유지된다.


#### 낙관적 검증 (Optimistic Validation)
- 트랜잭션이 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행
- 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영

#### 타임 스탬프 순서 (Time Stamp Ordering)
- 트랜잭션 실행 시작 전에 타임 스탬프를 부여
- 부여된 시간에 따라 트랜잭션 작업을 수행

#### 다중버전 동시성 제어 (MVCC)
- 트랜잭션의 타임 스탬프와 접근하려는 데이터의 타임 스탬프를 비교
- 직렬가능성이 보장되는 적절한 버전을 선택하여 접근

#### 2PC (2 Phase Commit)
- 분산 데이터베이스시스템에서 트랜잭션의 일관성을 유지하기 위한 기법
- 두 단계로 분리하여 제어:
  1. 준비 단계: 트랜잭션 수행 결과를 다른 분산 시스템에 알림
  2. 커밋 단계: 모든 분산 시스템에서 트랜잭션 수행 결과가 일치하는지 확인

## 6. 데이터베이스 고립화 수준 (Isolation Level)

### 6.1 고립화 수준 개념
고립화 수준은 다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 정도입니다.

### 6.2 고립화 수준 종류

| 수준 | 설명 |
|------|------|
| **Read Uncommitted** | - 커밋되지 않은 데이터 읽기 허용<br>- 연산 중인 데이터에 대한 연산은 불허 |
| **Read Committed** | - 커밋된 데이터만 읽기 허용<br>- 연산이 완료된 데이터만 다른 트랜잭션이 읽기 가능 |
| **Repeatable Read** | - 선행 트랜잭션이 읽은 데이터는 종료 시까지 다른 트랜잭션이 갱신/삭제 불가 |
| **Serializable Read** | - 선행 트랜잭션이 읽는 데이터 영역에 대한 다른 트랜잭션의 접근을 제한 |

## 7. 회복 기법 (Recovery)

회복의 개념
데이터의 손실이나 손상이 발생했을 때 이를 복구하는 과정
데이터베이스는 여러 가지 이유로 데이터가 손실되거나 손상될 수 있으며, 이는 하드웨어 오류, 소프트웨어 오류, 시스템 고장, 인간의 실수 등 다양한 원인으로 발생할 수 있다.
회복 작업은 데이터베이스 시스템이 데이터읨 무결성과 일관성을 유지하며, 손상된 데이터를 이전의 정상 상태로 복구하는 것을 목표로 한다.

회복 기법
로그 기반 복구
트랜잭션 실행 중에 발생한 모든 변경 사항을 로그에 기록한다.
로그는 장애 발생 시 데이터베이스를 이전 상태로 회복시키는 데 사용된다.
트랜잭션의 원자성을 보장하고, 장애로 인한 데이터 손실을 최소화한다..

체크포인트 기반 복구
정기적으로 체크포인트를 설정하여 데이터베이스의 일관성을 유지한다.
체크포인트는 데이터베이스의 상태를 지속적으로 기록하고, 장애 발생 시 체크포인트 이후의 로그를 사용하여 데이터를 복구한다.

### 7.1 회복 기법 개념
회복 기법은 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업입니다.

### 7.2 주요 회복 기법

#### REDO (재수행)
- 데이터베이스 비정상 종료 시 로그를 분석하여 완료된 트랜잭션 재작업
- 데이터베이스 손상 시 최근 복제본 적재 후 변경 내용 재실행
회복 작업 중에 사용되는 기법으로 트랜잭션의 변경 사항을 고르에 기록한 후, 장애 발생 시 로그를 기반으로 데이터를 재수행하여 회복하는 기법
장애로 인해 데이터가 손실되었을 때, 로그에 저장된 변경 사항을 순차적으로 재수행하여 데이터를 복구하는 역할
트랜잭션의 변경 사항은 로그에 기록된 후에 Commit되기 때문에 Commit 된 변경 사항은 장애 발생 시에도 반영된다.
데이터의 일관성을 유지하면서 데이터베이스의 회복을 보장하는 중요한 기법의 하나.


#### UNDO (취소, 되돌리기)
- 완료되지 않은 트랜잭션의 변경 내용을 모두 취소
- 변경 내용의 신뢰성 상실 시 모든 변경 내용을 취소하여 복원
회복 작업 중에 사용되는 기법으로, 롤백을 통해 트랜잭션의 변경 사항을 이전 상태로 되돌리는 기법
트랜잭션이 롤백 되면 해당 트랜잭션에서 발생한 변경 사항을 취소하고, 데이터베이스를 이전 상태로 복구한다.
트랜잭션의 변경 사항은 로그에 기록된 후에 Commit되기 때문에 롤백 작업시 로그를 사용하여 변경 사항을 식별하고 복구한다.
트랜잭션의 원자성을 보장하고, 장애로 인한 데이터 손실을 최소화하는데 중요한 역할을 한다.

### 7.3 회복 기법 종류

#### 로그 기반 회복 기법
1. **지연 갱신 회복 기법 (Deferred Update)**
   - 트랜잭션 완료 전까지 데이터베이스에 기록하지 않음
트랜잭션에서 데이터 변경 연산을 수행해도, 실제 데이터베이스에 반영하지 않고 로그에만 변경 내용을 기록하는 방법
트랜잭션이 commit되면, 변경 내용이 로그에 있는 상태로 남아 있게 된다.
Commit 이후에 회복 작업이 필요한 경우에만 로그를 기반으로 변경 내용을 디스크에 반영하여 데이터를 복구한다.
트랜잭션 간의 일관성을 유지하면서 변경 내용을 모아서 처리하기 때문에 성능을 향상시킬 수 있다.

미디어 회복 기법
디스크와 같은 비휘발성 저장 장치가 손상되는 장애 발생을 대비한 회복 기법이다.

2. **즉시 갱신 회복 기법 (Immediate Update)**
   - 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영
트랜잭션에서 데이터 변경 연산(INSERT, UPDATE, DELETE)을 수행할 때, 해당 연산을 즉시 디스크에 반영하는 기법
트랜잭션이 Commit되면, 변경된 데이터가 디스크에 반영되어 영구적인 저장이 이루어진다.
변경된 데이터가 즉시 확정되므로 데이터 무결성을 유지하고, 회복 시 복구 작업이 필요하지 않아 간단하고 빠른 처리가 가능하다.
장애가 발생하면 변경된 데이터가 디스크에 반영되었기 때문에 복구 작업을 수행해야 할 수도 있다.


#### 검사 시점 회복 기법 (Checkpoint Recovery)
- 검사점 이후 처리된 트랜잭션만 장애 발생 이전 상태로 복원
주기적으로 체크포인트를 설정하여 데이터베이스의 일관성을 유지하는 회복 기법
데이터베이스 상태를 지속적으로 기록하고, 장애 발생시 체크포인트 이후의 로그를 사용하여 데이터를 복구한다.
일정한 시간 간격이나 특정 이벤트(트랜잭션 수, 로그 크기 등)마다 체크포인트를 설정하여 데이터의 일관성과 회복 시간을 최적화할 수 있다.
로그 기반 복구와 함께 사용되며, 장애 발생 시 롤백 대상 로그의 양을 줄이고 복구 시간을 단축하는 장점이 있다.

#### 그림자 페이징 회복 기법 (Shadow Paging Recovery)
- 트랜잭션 수행 시 복제본을 생성하여 장애 시 복구에 활용
데이터베이스의 일관성을 유지하기 위해 그림자 페이지를 사용하는 회복 기법
데이터베이스 상태를 체크포인트 시점의 그림자 페이지로 저장하여 장애 발생 시 해당 그림자 페이지로 복구한다.
실제 데이터 페이지의 사본으로, 트랜잭션이 수행되는 동안에만 변경되며, Commit되지 않은 트랜잭션은 그림자 페이지에만 반영된다.
장애 발생 시 그림자 페이지를 복구하면 데이터 일관성을 유지할 수있다.
로그를 사용하지 않기 때문에 로그 오버헤드가 없고 성능이 우수하다는 장점이 있다.