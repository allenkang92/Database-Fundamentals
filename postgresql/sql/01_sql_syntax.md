### 1. SQL 기본 구문

#### 1.1 SQL 명령어 구조
- SELECT, INSERT, UPDATE, DELETE
- CREATE, ALTER, DROP
- COMMIT, ROLLBACK
- GRANT, REVOKE

#### 1.2 식별자와 키워드
- 예약어
- 대소문자 구분
- 따옴표 사용

### 2. 데이터 타입

#### 2.1 숫자 타입
- INTEGER, SMALLINT, BIGINT
- NUMERIC, DECIMAL
- REAL, DOUBLE PRECISION
- 시리얼 타입

#### 2.2 문자열 타입
- CHARACTER VARYING(n), VARCHAR(n)
- CHARACTER(n), CHAR(n)
- TEXT

#### 2.3 날짜/시간 타입
- DATE
- TIME
- TIMESTAMP
- INTERVAL

#### 2.4 기타 타입
- BOOLEAN
- ENUM
- UUID
- JSON, JSONB
- 배열 타입

### 3. 연산자

#### 3.1 산술 연산자
- 더하기 (+)
- 빼기 (-)
- 곱하기 (*)
- 나누기 (/)

#### 3.2 비교 연산자
- 같음 (=)
- 다름 (<>, !=)
- 크다 (>)
- 작다 (<)
- 크거나 같다 (>=)
- 작거나 같다 (<=)

#### 3.3 논리 연산자
- AND
- OR
- NOT

#### 3.4 특수 연산자
- LIKE
- IN
- BETWEEN
- IS NULL
- EXISTS

### 4. 표현식

#### 4.1 조건식
- CASE 표현식
- COALESCE
- NULLIF
- GREATEST, LEAST

#### 4.2 함수 호출
- 내장 함수
- 사용자 정의 함수
- 집계 함수

### 5. 주석

#### 5.1 한 줄 주석
- --로 시작

#### 5.2 여러 줄 주석
- /* */로 둘러싸기

어휘 구조
4.1.1. 식별자 및 키워드
4.1.2. 상수
4.1.3. 연산자
4.1.4. 특수 문자
4.1.5. 주석
4.1.6. 연산자 우선순위
SQL 입력은 일련의 명령으로 구성됩니다. 명령은 토큰 시퀀스로 구성되며 세미콜론(“;”)으로 종료됩니다. 입력 스트림의 끝도 명령을 종료합니다. 어떤 토큰이 유효한지는 특정 명령의 구문에 따라 다릅니다.

토큰은 키워드, 식별자, 인용된 식별자, 리터럴(또는 상수), 또는 특수 문자 기호일 수 있습니다. 토큰은 일반적으로 공백(공백, 탭, 줄바꿈)으로 구분되지만, 모호성이 없을 경우(일반적으로 특수 문자가 다른 토큰 유형과 인접한 경우에만 해당) 공백이 없어도 됩니다.

예를 들어, 다음은(구문적으로) 유효한 SQL 입력입니다:

```
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
```

이것은 세 개의 명령 시퀀스로, 각 줄마다 하나씩 있습니다(필수는 아니지만, 한 줄에 여러 명령을 넣을 수 있고 명령을 여러 줄에 걸쳐 유용하게 나눌 수 있습니다).

또한 SQL 입력에는 주석이 포함될 수 있습니다. 주석은 토큰이 아니며, 실제로는 공백과 동일하게 처리됩니다.

SQL 구문은 어떤 토큰이 명령을 식별하는지, 어떤 토큰이 피연산자나 매개변수를 식별하는지에 관해 일관성이 떨어집니다. 첫 몇 개의 토큰은 일반적으로 명령어 이름이므로 위의 예에서 우리는 일반적으로 “SELECT”, “UPDATE”, “INSERT” 명령어라고 말합니다. 그러나 예를 들어 UPDATE 명령은 항상 특정 위치에 SET 토큰이 나타나야 하며, 이 특정 INSERT 변형은 완료되기 위해 VALUES가 필요합니다. 각 명령의 정확한 구문 규칙은 파트 VI에 설명되어 있습니다.

4.1.1. 식별자 및 키워드
위 예에서 SELECT, UPDATE 또는 VALUES와 같은 토큰은 SQL 언어에서 고정된 의미를 가지는 키워드의 예입니다. MY_TABLE과 A는 식별자의 예로, 명령어에 따라 테이블, 열 또는 기타 데이터베이스 객체의 이름을 식별합니다. 따라서 때때로 단순히 “이름”이라고도 합니다. 키워드와 식별자는 동일한 어휘 구조를 가지므로, 언어를 알지 못하면 토큰이 식별자인지 키워드인지 알 수 없습니다. 키워드의 전체 목록은 부록 C에서 확인할 수 있습니다.

SQL 식별자와 키워드는 문자(a-z, 악센트가 있는 문자 및 비라틴 문자를 포함) 또는 언더스코어(_)로 시작해야 합니다. 식별자나 키워드의 다음 문자는 문자, 언더스코어, 숫자(0-9) 또는 달러 기호($)일 수 있습니다. SQL 표준에 따르면 식별자에는 달러 기호가 허용되지 않으므로 이를 사용하면 애플리케이션의 이식성이 떨어질 수 있습니다. SQL 표준은 숫자가 포함되거나 언더스코어로 시작하거나 끝나는 키워드를 정의하지 않으므로 이러한 형식의 식별자는 미래 표준 확장과의 잠재적 충돌로부터 안전합니다.

시스템은 식별자당 NAMEDATALEN-1 바이트를 초과하지 않습니다. 더 긴 이름은 명령에 작성할 수 있지만 잘릴 것입니다. 기본적으로 NAMEDATALEN은 64이므로 최대 식별자 길이는 63바이트입니다. 이 제한이 문제가 되는 경우 src/include/pg_config_manual.h의 NAMEDATALEN 상수를 변경하여 늘릴 수 있습니다.

키워드와 인용되지 않은 식별자는 대소문자를 구분하지 않습니다. 따라서:

```
UPDATE MY_TABLE SET A = 5;
```

는 다음과 같이 쓸 수 있습니다:

```
uPDaTE my_TabLE SeT a = 5;
```

일반적으로 키워드는 대문자로, 이름은 소문자로 쓰는 관례가 자주 사용됩니다. 예를 들어:

```
UPDATE my_table SET a = 5;
```

인용된 식별자는 항상 식별자이며, 절대 키워드가 아닙니다. 따라서 "select"는 열이나 테이블 이름 “select”를 참조하는 데 사용할 수 있지만, 인용되지 않은 select는 키워드로 간주되어 테이블이나 열 이름이 예상되는 위치에서 사용하면 구문 분석 오류를 일으킵니다. 예제는 다음과 같이 인용된 식별자를 사용하여 쓸 수 있습니다:

```
UPDATE "my_table" SET "a" = 5;
```

인용된 식별자는 0번 코드 문자를 제외한 모든 문자를 포함할 수 있습니다. (따옴표를 포함하려면 두 개의 따옴표를 씁니다.) 이는 공백이나 앰퍼샌드가 포함된 이름과 같이 그렇지 않으면 불가능한 테이블이나 열 이름을 구성할 수 있게 합니다. 길이 제한은 여전히 적용됩니다.

식별자를 인용하면 대소문자를 구분하게 되며, 인용되지 않은 이름은 항상 소문자로 변환됩니다. 예를 들어, 식별자 FOO, foo 및 "foo"는 PostgreSQL에서 동일하게 간주되지만, "Foo"와 "FOO"는 이 세 식별자와 모두 다릅니다. (PostgreSQL에서 인용되지 않은 이름을 소문자로 변환하는 것은 표준 SQL과 호환되지 않으며, 표준에서는 인용되지 않은 이름을 대문자로 변환해야 한다고 명시되어 있습니다. 따라서 표준에 따라 foo는 "FOO"와 동등해야 하지만 PostgreSQL에서는 그렇지 않습니다. 이식 가능한 애플리케이션을 작성하려면 특정 이름을 항상 인용하거나 전혀 인용하지 않는 것이 좋습니다.)

인용된 식별자의 변형은 코드 포인트로 식별되는 이스케이프된 유니코드 문자를 포함할 수 있습니다. 이 변형은 여는 따옴표 바로 앞에 공백 없이 U&(대소문자 U와 앰퍼샌드)가 시작됩니다. 예를 들면 U&"foo"입니다. (이것은 연산자 &와의 모호성을 초래할 수 있으므로 연산자 주위에 공백을 사용하여 이 문제를 피하십시오.) 따옴표 안에서는 유니코드 문자를 이스케이프된 형식으로 지정할 수 있습니다. 예를 들어 문자열 "data"는 다음과 같이 쓸 수 있습니다.

```
U&"d\0061t\+000061"
```

러시아어 단어 “slon”(코끼리)을 키릴 문자로 쓰는 덜 단순한 예는 다음과 같습니다:

```
U&"\0441\043B\043О\043Н"
```

백슬래시 외에 다른 이스케이프 문자를 원하는 경우, 문자열 뒤에 UESCAPE 절을 사용하여 지정할 수 있습니다. 예를 들어:

```
U&"d!0061t!+000061" UESCAPE '!'
```

이스케이프 문자는 16진수 숫자, 더하기 기호, 작은따옴표, 큰따옴표 또는 공백 문자를 제외한 단일 문자여야 합니다. 이스케이프 문자를 식별자에 문자 그대로 포함하려면 두 번 씁니다.

4자리 또는 6자리 이스케이프 형식을 사용하여 U+FFFF보다 큰 코드 포인트를 가진 문자를 구성하기 위해 UTF-16 서로게이트 페어를 지정할 수 있습니다. 그러나 6자리 형식이 가능하므로 이는 기술적으로 불필요할 수 있습니다. (서로게이트 페어는 직접 저장되지 않고 단일 코드 포인트로 결합됩니다.)

서버 인코딩이 UTF-8이 아닌 경우, 이러한 이스케이프 시퀀스 중 하나에 의해 식별된 유니코드 코드 포인트는 실제 서버 인코딩으로 변환됩니다. 변환이 불가능하면 오류가 보고됩니다.

문자열 상수에 대한 유니코드 이스케이프 구문은 구성 매개변수 standard_conforming_strings가 켜져 있을 때만 작동합니다. 그렇지 않으면 이 구문이 SQL 삽입 및 유사한 보안 문제로 이어질 수 있어 SQL 구문을 파싱하는 클라이언트를 혼란스럽게 할 수 있습니다. 매개변수가 꺼져 있으면 이 구문은 오류 메시지와 함께 거부됩니다.

4.1.2. 상수
PostgreSQL에는 세 가지 종류의 암묵적 유형 상수가 있습니다: 문자열, 비트 문자열, 숫자. 상수는 또한 명시적 유형으로 지정할 수 있으며, 이는 시스템에 의해 보다 정확한 표현과 효율적인 처리를 가능하게 할 수 있습니다. 이러한 대안은 다음 섹션에서 논의됩니다.

4.1.2.1. 문자열 상수
SQL에서 문자열 상수는 작은따옴표(')로 둘러싸인 임의의 문자 시퀀스입니다. 예를 들어 'This is a string'입니다. 문자열 상수 내에 작은따옴표 문자를 포함하려면 두 개의 인접한 작은따옴표를 씁니다. 예: 'Dianne''s horse'. 이는 큰따옴표(")와 동일하지 않습니다.

공백과 함께 적어도 하나의 줄바꿈이 있는 두 개의 문자열 상수는 결합되며, 사실상 하나의 상수로 처리됩니다. 예를 들어:

```
SELECT 'foo'
'bar';
```

는 다음과 동일합니다:

```
SELECT 'foobar';
```

하지만:

```
SELECT 'foo'      'bar';
```

는 유효한 구문이 아닙니다. (이 다소 기이한 동작은 SQL 표준에 의해 규정되어 있으며, PostgreSQL은 표준을 따르고 있습니다.)

4.1.2.2. C 스타일 이스케이프가 있는 문자열 상수
PostgreSQL은 SQL 표준의 확장인 “이스케이프” 문자열 상수도 허용합니다. 이스케이프 문자열 상수는 시작 작은따옴표 바로 앞에 E(대소문자 모두 가능)를 작성하여 지정됩니다. 예: E'foo'. (이스케이프 문자열 상수를 여러 줄에 걸쳐 계속 작성할 경우 처음 여는 작은따옴표 앞에만 E를 씁니다.) 이스케이프 문자열 내에서는 백슬래시(\) 문자가 C-유사한 백슬래시 이스케이프 시퀀스를 시작하며, 이는 특수 바이트 값을 나타냅니다. 이는 표 4.1에 나와 있습니다.

표 4.1. 백슬래시 이스케이프 시퀀스

| 백슬래시 이스케이프 시퀀스 | 해석 |
|-----------------------------|------|
| \b                          | 백스페이스 |
| \f                          | 폼 피드 |
| \n                          | 새 줄 |
| \r                          | 캐리지 리턴 |
| \t                          | 탭 |
| \o, \oo, \ooo (o = 0–7)    | 8진수 바이트 값 |
| \xh, \xhh (h = 0–9, A–F)   | 16진수 바이트 값 |
| \uxxxx, \Uxxxxxxxx           | 16 또는 32비트 16진수 유니코드 문자 값 |

백슬래시 다음에 오는 다른 문자는 문자 그대로 처리됩니다. 따라서 백슬래시 문자를 포함하려면 두 개의 백슬래시(\\)를 씁니다. 또한 작은따옴표는 이스케이프 문자열 내에서 \', 또는 일반적인 '' 방법으로 포함할 수 있습니다.

작성하는 바이트 시퀀스, 특히 8진수나 16진수 이스케이프를 사용할 때는 서버 문자 집합 인코딩에서 유효한 문자를 구성하는지 책임이 있습니다. 유용한 대안은 섹션 4.1.2.3에서 설명된 유니코드 이스케이프 또는 대체 유니코드 이스케이프 구문을 사용하는 것입니다. 그러면 서버는 문자 변환이 가능한지 확인합니다.

주의
구성 매개변수 standard_conforming_strings가 꺼져 있으면 PostgreSQL은 일반 및 이스케이프 문자열 상수 모두에서 백슬래시 이스케이프를 인식합니다. 그러나 PostgreSQL 9.1부터 기본값은 켜져 있으며, 이는 이스케이프 문자열 상수에서만 백슬래시 이스케이프를 인식함을 의미합니다. 이 동작은 표준을 더 준수하지만, 백슬래시 이스케이프가 항상 인식되던 과거의 동작에 의존하는 애플리케이션을 깨뜨릴 수 있습니다. 이 매개변수를 꺼서 이 문제를 해결할 수 있지만, 백슬래시 이스케이프 사용을 중단하는 것이 좋습니다. 특별한 문자를 나타내기 위해 백슬래시 이스케이프를 사용해야 하는 경우, E를 사용하여 문자열 상수를 작성하십시오.

standard_conforming_strings 외에도 구성 매개변수 escape_string_warning 및 backslash_quote는 문자열 상수에서 백슬래시의 처리 방식을 제어합니다.

코드가 0인 문자는 문자열 상수에 포함될 수 없습니다.

4.1.2.3. 유니코드 이스케이프가 있는 문자열 상수
PostgreSQL은 유니코드 문자 코드를 통해 임의의 유니코드 문자를 지정할 수 있는 또 다른 유형의 이스케이프 구문을 지원합니다. 유니코드 이스케이프 문자열 상수는 열리는 따옴표 바로 앞에 U&(대소문자 U와 앰퍼샌드)를 붙여 시작됩니다. 예: U&'foo'. (이것은 연산자 &와의 모호성을 초래할 수 있으므로 연산자 주위에 공백을 사용하여 이 문제를 피하십시오.) 따옴표 안에서는 유니코드 문자를 이스케이프된 형식으로 지정할 수 있습니다. 예를 들어 문자열 'data'는 다음과 같이 쓸 수 있습니다:

```
U&'d\0061t\+000061'
```

러시아어 단어 “slon”(코끼리)을 키릴 문자로 쓰는 덜 단순한 예는 다음과 같습니다:

```
U&'\0441\043B\043О\043Н'
```

백슬래시 외에 다른 이스케이프 문자를 원하는 경우, 문자열 뒤에 UESCAPE 절을 사용하여 지정할 수 있습니다. 예를 들어:

```
U&'d!0061t!+000061' UESCAPE '!'
```

이스케이프 문자는 16진수 숫자, 더하기 기호, 작은따옴표, 큰따옴표 또는 공백 문자를 제외한 단일 문자여야 합니다.

이스케이프 문자를 문자열에 문자 그대로 포함하려면 두 번 씁니다.

4자리 또는 6자리 이스케이프 형식을 사용하여 U+FFFF보다 큰 코드 포인트를 가진 문자를 구성할 수 있습니다. 6자리 형식의 가용성은 기술적으로 이를 불필요하게 만듭니다. (서로게이트 페어는 직접 저장되지 않고, 단일 코드 포인트로 결합됩니다.)

서버 인코딩이 UTF-8이 아닌 경우, 이러한 이스케이프 시퀀스 중 하나에 의해 식별된 유니코드 코드 포인트는 실제 서버 인코딩으로 변환됩니다. 변환이 불가능하면 오류가 보고됩니다.

문자열 상수에 대한 유니코드 이스케이프 구문은 구성 매개변수 standard_conforming_strings가 켜져 있을 때만 작동합니다. 그렇지 않으면 이 구문이 SQL 삽입 및 유사한 보안 문제로 이어질 수 있어 SQL 구문을 파싱하는 클라이언트를 혼란스럽게 할 수 있습니다. 매개변수가 꺼져 있으면 이 구문은 오류 메시지와 함께 거부됩니다.

4.1.2.4. 달러 인용 문자열 상수
표준 구문인 작은따옴표를 사용하는 문자열 상수는 편리하지만, 원하는 문자열에 작은따옴표가 많을 경우 이해하기 어려울 수 있습니다. 이를 보다 읽기 쉽게 하기 위해 PostgreSQL은 “달러 인용”이라는 다른 방법을 제공합니다. 달러 인용 문자열 상수는 달러 기호($), 선택적 “태그” 0개 이상의 문자, 또 다른 달러 기호, 문자열 내용의 임의 시퀀스, 다시 달러 기호, 시작 태그와 동일한 태그, 그리고 마지막 달러 기호로 구성됩니다. 예를 들어, 달러 인용을 사용하여 문자열 “Dianne's horse”를 지정하는 두 가지 방법은 다음과 같습니다:

```
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
```

달러 인용 문자열 내에서는 작은따옴표를 이스케이프할 필요 없이 사용할 수 있습니다. 실제로, 달러 인용 문자열 내에서는 작은따옴표나 기타 문자가 절대 이스케이프되지 않습니다: 문자열 내용은 항상 문자 그대로 작성됩니다. 백슬래시는 특별한 의미를 가지지 않으며, 달러 기호도 열리는 태그와 일치하는 시퀀스가 아닌 한 특별한 의미를 가지지 않습니다.

각 인용 레벨에서 다른 태그를 선택하여 달러 인용 문자열 상수를 중첩할 수 있습니다. 이는 함수 정의를 작성할 때 가장 일반적으로 사용됩니다. 예를 들어:

```
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
```

여기서 $q$[\t\r\n\v\\]$q$ 시퀀스는 달러 인용 리터럴 문자열 [\t\r\n\v\\]을 나타내며, 이는 PostgreSQL이 함수 본문을 실행할 때 인식됩니다. 그러나 이 시퀀스는 외부 달러 인용 구분자 $function$과 일치하지 않으므로, 외부 문자열과 관련하여 단순히 더 많은 문자로 간주됩니다.

달러 인용의 태그는 달러 기호를 포함할 수 없다는 점을 제외하고는 인용되지 않은 식별자와 동일한 규칙을 따릅니다. 태그는 대소문자를 구분하므로, $tag$String content$tag$는 올바르지만 $TAG$String content$tag$는 올바르지 않습니다.

달러 인용은 SQL 표준의 일부가 아니지만, 표준을 준수하는 단일 인용 구문보다 복잡한 문자열 리터럴을 작성할 때 더 편리한 방법인 경우가 많습니다. 이는 특히 프로시저 함수 정의에서 다른 상수 내의 문자열 상수를 나타내야 할 때 유용합니다. 작은따옴표 구문을 사용할 경우 위 예제의 각 백슬래시는 네 개의 백슬래시로 작성되어야 하며, 이는 원래 문자열 상수를 구문 분석할 때 두 개의 백슬래시로 줄어들고, 함수 실행 중에 내부 문자열 상수를 다시 구문 분석할 때 하나의 백슬래시로 줄어듭니다.

4.1.2.5. 비트 문자열 상수
비트 문자열 상수는 B(대소문자 모두 가능)가 열리는 따옴표 바로 앞에 오는 일반적인 문자열 상수처럼 보입니다. 예: B'1001'. 비트 문자열 상수 내에서 허용되는 유일한 문자는 0과 1입니다.

또는 16진수 표기법을 사용하여 비트 문자열 상수를 지정할 수 있습니다. 앞에 X(대소문자 모두 가능)를 붙입니다. 예: X'1FF'. 이 표기법은 각 16진수 숫자당 네 개의 이진 숫자를 가진 비트 문자열 상수와 동일합니다.

두 가지 형태의 비트 문자열 상수는 일반 문자열 상수와 동일한 방식으로 여러 줄에 걸쳐 계속할 수 있습니다. 달러 인용은 비트 문자열 상수에서 사용할 수 없습니다.

4.1.2.6. 숫자 상수
숫자 상수는 일반적으로 다음 형식으로 허용됩니다:

- digits
- digits.[digits][e[+-]digits]
- [digits].digits[e[+-]digits]
- digitse[+-]digits

여기서 digits는 하나 이상의 10진수 숫자(0~9)입니다. 소수점을 사용하는 경우 소수점 전후에 적어도 하나의 숫자가 있어야 하고, 지수 표기법(e)이 있는 경우, 지수 기호 뒤에 적어도 하나의 숫자가 와야 합니다. 상수 내에는 공백이나 다른 문자가 포함될 수 없으며, 시각적 그룹화를 위해 밑줄(_)만 사용할 수 있습니다. 예:

```
1_500_000_000
0b10001000_00000000
0o_1_755
0xFFFF_FFFF
1.618_034
```

밑줄은 숫자 상수 또는 숫자 그룹의 시작이나 끝, 소수점 앞이나 뒤, 지수 기호 앞이나 뒤에 올 수 없으며, 연속으로 두 개 이상의 밑줄을 사용할 수 없습니다.

소수점이나 지수가 포함되지 않은 숫자 상수가 제공될 경우, 값이 정수형(32비트)에 맞으면 정수형으로, 그렇지 않고 큰 경우 bigint(64비트)로, 그 외의 경우 numeric 유형으로 추정됩니다. 소수점이나 지수가 포함된 상수는 항상 numeric 유형으로 추정됩니다.

숫자 상수의 초기 할당 데이터 유형은 유형 해석 알고리즘의 시작점일 뿐입니다. 대부분의 경우, 상수는 컨텍스트에 따라 가장 적절한 유형으로 자동 강제 변환됩니다. 필요한 경우, 캐스팅을 통해 특정 데이터 유형으로 해석되도록 숫자 값을 강제할 수 있습니다. 예를 들어, 다음과 같이 작성하여 숫자 값을 실수형(float4)으로 처리하도록 강제할 수 있습니다:

```
REAL '1.23'  -- 문자열 스타일
1.23::REAL   -- PostgreSQL(역사적) 스타일
```

이들은 실제로 다음에 설명된 일반 캐스팅 표기법의 특수 사례입니다.

4.1.2.7. 다른 유형의 상수
임의의 유형 상수는 다음 중 하나의 표기법을 사용하여 입력할 수 있습니다:

- type 'string'
- 'string'::type
- CAST ( 'string' AS type )

문자열 상수의 텍스트는 type에 지정된 타입의 입력 변환 루틴으로 전달됩니다. 결과는 지정된 유형의 상수가 됩니다. 명시적 유형 캐스트는 상수가 반드시 가져야 하는 유형에 대해 모호성이 없을 경우 생략할 수 있으며, 이 경우 자동으로 강제 변환됩니다.

문자열 상수는 일반 SQL 표기법이나 달러 인용을 사용하여 작성할 수 있습니다.

함수 호출 형태:
```
typename ( 'string' )
```
하지만 모든 유형 이름이 이 방식으로 사용될 수 있는 것은 아니며, 자세한 내용은 섹션 4.2.9를 참조하십시오.

::, CAST(), 함수 호출 구문은 임의의 표현식에 대한 런타임 유형 변환을 지정하는 데에도 사용할 수 있으며, 이는 섹션 4.2.9에서 논의됩니다. 구문 모호성을 피하기 위해 type 'string' 구문은 단순 리터럴 상수의 유형을 지정하는 데에만 사용할 수 있습니다. 배열 유형의 경우, type 'string' 구문은 작동하지 않으므로 배열 상수의 유형을 지정하려면 :: 또는 CAST()를 사용하십시오.

CAST() 구문은 SQL과 호환됩니다. type 'string' 구문은 표준의 일부를 일반화한 것으로, SQL은 몇 가지 데이터 유형에 대해서만 이 구문을 지정하지만 PostgreSQL은 모든 유형에 대해 이를 허용합니다. :: 구문은 PostgreSQL의 역사적 사용이며, 함수 호출 구문도 마찬가지입니다.

4.1.3. 연산자
연산자 이름은 다음 목록에 있는 최대 NAMEDATALEN-1(기본값은 63) 문자로 구성된 시퀀스입니다:

```
+ - * / < > = ~ ! @ # % ^ & | ` ?
```

그러나 연산자 이름에는 몇 가지 제한이 있습니다:

- -- 및 /*는 연산자 이름 어디에서도 나타날 수 없습니다. 이는 주석의 시작으로 해석되기 때문입니다.
- 여러 문자로 된 연산자 이름은 + 또는 -로 끝날 수 없습니다. 단, 이름에 다음 문자 중 하나 이상이 포함된 경우는 예외입니다:

```
~ ! @ # % ^ & | ` ?
```

예를 들어, @-는 허용된 연산자 이름이지만, *-는 허용되지 않습니다. 이 제한은 PostgreSQL이 연산자 사이에 공백을 요구하지 않고 SQL 호환 쿼리를 파싱할 수 있게 합니다.

SQL 표준이 아닌 연산자 이름을 사용할 때는 일반적으로 모호성을 피하기 위해 인접한 연산자를 공백으로 구분해야 합니다. 예를 들어, 접두사 연산자 @를 정의한 경우, 다음과 같이 작성할 수 없습니다:

```
X*@Y;
```

대신 다음과 같이 작성해야 합니다:

```
X* @Y
```

이는 PostgreSQL이 이를 하나의 연산자 이름이 아닌 두 개의 연산자 이름으로 인식하도록 보장합니다.

내장 연산자와 동일한 이름을 갖는 사용자 정의 연산자의 경우, 해당 연산자는 위에서 언급한 내장 연산자와 동일한 우선순위를 가집니다. 예를 들어, 사용자 정의 데이터 유형에 대한 "+" 연산자를 정의하면, 내장 "+" 연산자와 동일한 우선순위를 가집니다.

스키마 한정 연산자 이름이 OPERATOR 구문에서 사용될 때, 예를 들어:

```
SELECT 3 OPERATOR(pg_catalog.+) 4;
```

OPERATOR 구문은 표 4.2에서 “다른 모든 연산자”에 대한 기본 우선순위를 갖습니다. 이는 OPERATOR() 안에 어떤 특정 연산자가 있는지와 상관없이 적용됩니다.

주의
PostgreSQL 9.5 이전 버전에서는 연산자 우선순위 규칙이 약간 다르게 처리되었습니다. 특히 <=, >= 및 <>는 일반 연산자로 처리되었으며, IS 테스트는 더 높은 우선순위를 가졌고, NOT BETWEEN 및 관련 구문은 논리적으로 동등한 구문을 일관되게 처리하지 않았습니다. 이러한 규칙은 SQL 표준과의 호환성을 개선하고 논리적으로 동등한 구문의 일관성을 높이기 위해 변경되었습니다. 대부분의 경우, 이러한 변경은 동작에 영향을 미치지 않거나, 괄호를 추가하여 해결할 수 있는 “해당 연산자가 없습니다”와 같은 오류를 초래할 수 있습니다. 그러나 일부 극단적인 경우 쿼리의 동작이 구문 분석 오류 없이 변경될 수 있습니다.

값 표현식
4.2.1. 열 참조
4.2.2. 위치 매개변수
4.2.3. 첨자
4.2.4. 필드 선택
4.2.5. 연산자 호출
4.2.6. 함수 호출
4.2.7. 집계 표현식
4.2.8. 윈도우 함수 호출
4.2.9. 유형 캐스트
4.2.10. 콜레이션 표현식
4.2.11. 스칼라 서브쿼리
4.2.12. 배열 생성자
4.2.13. 행 생성자
4.2.14. 표현식 평가 규칙
값 표현식은 SELECT 명령의 대상 목록, INSERT 또는 UPDATE의 새로운 열 값, 또는 여러 명령의 검색 조건과 같은 다양한 컨텍스트에서 사용됩니다. 값 표현식의 결과는 테이블 표현식의 결과(테이블)와 구별하기 위해 때때로 스칼라라고 합니다. 따라서 값 표현식은 스칼라 표현식(또는 단순히 표현식)이라고도 합니다. 표현식 구문은 산술, 논리, 집합 및 기타 연산을 사용하여 기본 구성 요소에서 값을 계산할 수 있습니다.

값 표현식은 다음 중 하나입니다:

- 상수 또는 리터럴 값
- 열 참조
- 위치 매개변수 참조
- 첨자 표현식
- 필드 선택 표현식
- 연산자 호출
- 함수 호출
- 집계 표현식
- 윈도우 함수 호출
- 유형 캐스트
- 콜레이션 표현식
- 스칼라 서브쿼리
- 배열 생성자
- 행 생성자
- 괄호 안의 다른 값 표현식 (서브 표현식을 그룹화하고 우선순위를 재정의하는 데 사용됨)

이 목록 외에도 표현식으로 분류될 수 있지만 일반적인 구문 규칙을 따르지 않는 여러 구문이 있습니다. 이러한 구문은 일반적으로 함수 또는 연산자의 의미를 가지며, 적절한 위치에서 설명됩니다. 예를 들어, IS NULL 절이 그 예입니다.

우리는 이미 섹션 4.1.2에서 상수에 대해 논의했습니다. 다음 섹션에서는 나머지 옵션에 대해 논의합니다.

4.2.1. 열 참조
열은 다음 형태로 참조될 수 있습니다:

```
correlation.columnname
```

여기서 correlation은 FROM 절을 통해 정의된 테이블의 이름(스키마 이름으로 한정될 수 있음) 또는 테이블의 별칭입니다. 특히 참조 중인 모든 테이블에서 열 이름이 고유한 경우, 관계 이름과 점을 생략할 수 있습니다. (자세한 내용은 7장을 참조하십시오.)

4.2.2. 위치 매개변수
위치 매개변수 참조는 SQL 명령에 외부에서 제공되는 값을 나타내는 데 사용됩니다. 매개변수는 SQL 함수 정의와 준비된 쿼리에서 사용됩니다. 일부 클라이언트 라이브러리는 SQL 명령 문자열과 별도로 데이터 값을 지정하는 것을 지원하며, 이 경우 매개변수는 외부 데이터 값을 참조하는 데 사용됩니다. 매개변수 참조의 형식은 다음과 같습니다:

```
$number
```

예를 들어, 함수 dept의 정의는 다음과 같습니다:

```
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
```

여기서 $1은 함수가 호출될 때 첫 번째 함수 인수의 값을 참조합니다.

4.2.3. 첨자
연산자가 배열 유형의 값을 반환하는 표현식인 경우, 배열 값의 특정 요소를 추출할 수 있습니다:

```
expression[subscript]
```

또는 인접한 여러 요소(“배열 슬라이스”)를 추출할 수 있습니다:

```
expression[lower_subscript:upper_subscript]
```

각 첨자는 자체적으로 표현식이며, 가장 가까운 정수 값으로 반올림됩니다.

일반적으로 배열 표현식은 괄호로 묶어야 하지만, 첨자 표현식을 서브스크립트로 사용하는 경우 표현식이 단순한 열 참조나 위치 매개변수인 경우 괄호를 생략할 수 있습니다. 또한, 원래 배열이 다차원인 경우 여러 첨자를 연쇄할 수 있습니다. 예:

```
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
```

마지막 예제에서는 괄호가 필요합니다. 배열에 대한 추가 정보는 섹션 8.15를 참조하십시오.

4.2.4. 필드 선택
복합 유형(행 유형)의 값을 반환하는 표현식인 경우, 행의 특정 필드를 추출할 수 있습니다:

```
expression.fieldname
```

일반적으로 행 표현식은 괄호로 묶어야 하지만, 선택하려는 표현식이 단순한 테이블 참조나 위치 매개변수인 경우 괄호를 생략할 수 있습니다. 예:

```
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
```

특히, 복합 유형의 테이블 열에서 필드를 추출하는 중요한 특별한 경우:

```
(compositecol).somefield
(mytable.compositecol).somefield
```

여기서 괄호는 compositecol이 열 이름인지, mytable이 스키마 이름인지 나타내기 위해 필요합니다.

복합 값의 모든 필드를 요청하려면 .*를 쓸 수 있습니다:

```
(compositecol).*
```

이 표기법은 컨텍스트에 따라 다르게 동작합니다. 자세한 내용은 섹션 8.16.5를 참조하십시오.

4.2.5. 연산자 호출
연산자 호출에는 두 가지 가능한 구문이 있습니다:

- 이항 중위 연산자: `expression operator expression`
- 단항 접두 연산자: `operator expression`

여기서 연산자 토큰은 섹션 4.1.3의 구문 규칙을 따르거나 AND, OR, NOT과 같은 키워드 중 하나이거나 다음과 같은 형식의 한정된 연산자 이름일 수 있습니다:

```
OPERATOR(schema.operatorname)
```

특정 연산자가 어떤 연산자인지 여부는 시스템이나 사용자가 정의한 연산자에 따라 다릅니다. 내장 연산자에 대해서는 9장을 참조하십시오.

4.2.6. 함수 호출
함수 호출의 구문은 함수 이름(스키마 이름으로 한정될 수 있음) 뒤에 괄호로 감싼 인수 목록을 따릅니다:

```
function_name ([expression [, expression ... ]] )
```

예를 들어, 다음은 2의 제곱근을 계산합니다:

```
sqrt(2)
```

내장 함수 목록은 9장에서 확인할 수 있으며, 다른 함수는 사용자가 추가할 수 있습니다.

데이터베이스에서 일부 사용자가 다른 사용자를 신뢰하지 않는 경우, 함수 호출 시 보안 예방 조치를 준수하십시오(섹션 10.3 참조).

인수에는 선택적으로 이름을 붙일 수 있습니다. 자세한 내용은 섹션 4.3을 참조하십시오.

주의
복합 유형의 단일 인수를 받는 함수는 선택적으로 필드 선택 구문을 사용하여 호출할 수 있으며, 반대로 필드 선택을 함수 호출 형식으로 작성할 수도 있습니다. 즉, `col(table)`과 `table.col` 표기법은 상호 교환이 가능합니다. 이 동작은 SQL 표준이 아니지만, PostgreSQL에서는 “계산된 필드”를 모방하기 위해 함수를 사용할 수 있게 하기 위해 제공됩니다. 자세한 내용은 섹션 8.16.5를 참조하십시오.

4.2.7. 집계 표현식
집계 표현식은 쿼리에 의해 선택된 행 전체에 걸쳐 집계 함수를 적용하는 것을 나타냅니다. 집계 함수는 입력이 여러 개인 경우 이를 하나의 출력 값으로 축소하며, 합계나 평균이 그 예입니다. 집계 표현식의 구문은 다음 중 하나입니다:

- `aggregate_name (expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]`
- `aggregate_name (ALL expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]`
- `aggregate_name (DISTINCT expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]`
- `aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ]`
- `aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]`

여기서 `aggregate_name`은 이전에 정의된 집계 함수(스키마 이름으로 한정될 수 있음)이며, `expression`은 자체적으로 집계 표현식이나 윈도우 함수 호출을 포함하지 않는 임의의 값 표현식입니다. 선택적인 order_by_clause 및 filter_clause는 아래에서 설명됩니다.

첫 번째 형태의 집계 표현식은 입력 행마다 집계를 한 번씩 호출합니다. 두 번째 형태는 ALL이 기본값이므로 첫 번째 형태와 동일합니다. 세 번째 형태는 표현식(또는 여러 표현식)의 각 고유한 값마다 집계를 한 번씩 호출합니다. 네 번째 형태는 입력 행마다 집계를 한 번씩 호출하며, 특정 입력 값이 지정되지 않으므로 일반적으로 count(*) 집계 함수에만 유용합니다. 마지막 형태는 ordered-set 집계 함수와 함께 사용됩니다. 이는 아래에서 설명됩니다.

대부분의 집계 함수는 null 입력을 무시하므로, 표현식이 null을 반환하는 입력 행은 무시됩니다. 이는 내장된 모든 집계에 대해 달리 명시되지 않는 한, 기본적으로 참입니다.

예를 들어, count(*)는 전체 입력 행의 수를 반환하고, count(f1)는 f1이 null이 아닌 입력 행의 수를 반환하며, count(distinct f1)는 f1의 고유하고 null이 아닌 값의 수를 반환합니다.

일반적으로 입력 행은 지정되지 않은 순서로 집계 함수에 전달됩니다. 많은 경우, 이는 문제되지 않습니다. 예를 들어, min은 입력 순서와 관계없이 동일한 결과를 생성합니다. 그러나 일부 집계 함수(예: array_agg 및 string_agg)는 입력 행의 순서에 따라 결과가 달라집니다. 이러한 집계를 사용할 때는 선택적인 order_by_clause를 사용하여 원하는 순서를 지정할 수 있습니다. order_by_clause는 쿼리 수준의 ORDER BY 절과 동일한 구문을 가지지만, 그 표현식은 항상 단순한 표현식이어야 하며 출력 열 이름이나 번호는 사용할 수 없습니다. 예를 들어:

```
WITH vals (v) AS ( VALUES (1),(3),(4),(3),(2) )
SELECT array_agg(v ORDER BY v DESC) FROM vals;
  array_agg
-------------
 {4,3,3,2,1}
```

jsonb는 일치하는 마지막 키만 유지하므로 키의 순서가 중요할 수 있습니다:

```
WITH vals (k, v) AS ( VALUES ('key0','1'), ('key1','3'), ('key1','2') )
SELECT jsonb_object_agg(k, v ORDER BY v) FROM vals;
      jsonb_object_agg
----------------------------
 {"key0": "1", "key1": "3"}
```

다중 인수 집계 함수와 함께 사용할 때, order_by_clause는 모든 집계 인수 뒤에 와야 합니다. 예를 들어, 다음과 같이 작성하십시오:

```
SELECT string_agg(a, ',' ORDER BY a) FROM table;
```

다음과 같이 작성하지 마십시오:

```
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- 잘못됨
```

후자는 구문적으로 유효하지만, 두 개의 ORDER BY 키(두 번째 키는 상수이므로 실용적이지 않음)를 가진 단일 인수 집계 함수의 호출을 나타냅니다.

DISTINCT와 함께 order_by_clause가 지정된 경우, ORDER BY 표현식은 DISTINCT 목록의 열만 참조할 수 있습니다. 예를 들어:

```
WITH vals (v) AS ( VALUES (1),(3),(4),(3),(2) )
SELECT array_agg(DISTINCT v ORDER BY v DESC) FROM vals;
 array_agg
-----------
 {4,3,2,1}
```

현재 명명된 호출 및 혼합 호출 표기법은 집계 함수를 호출할 때 사용할 수 없습니다(하지만 집계 함수가 윈도우 함수로 사용될 때는 작동합니다).